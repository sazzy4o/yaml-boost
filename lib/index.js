function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const fs = require('fs');

const path = require('path');

const get = require('lodash.get');

const set = require('lodash.set');

const mergeWith = require('lodash.mergewith');

const yaml = require('js-yaml');

const concatArrays = (objValue, srcValue) => [objValue, srcValue].every(Array.isArray) ? objValue.concat(srcValue) : undefined;

const loadRecursive = (dir, relDir, data, vars) => {
  let result = data;

  if (typeof result === 'string' || result instanceof String) {
    // replace yaml variables with defaults
    result = result.replace(/\${opt:([a-zA-Z0-9]+?)(?:, ["']([a-zA-Z0-9\-.]+?)["'])?}/g, (match, k, v) => get(vars, k, v || match)); // load requires

    const match = // eslint-disable-next-line max-len
    /\${(require|file|fileFn|env)(?:\(([~^]?[a-zA-Z\d._\-@/]+?)\))?(?::([a-zA-Z\d.]+?))?(?:, ([a-zA-Z\d=\-&/.:[\],]+?))?}/g.exec(result);

    if (match) {
      const varsNew = _objectSpread(_objectSpread({}, vars), match[4] ? JSON.parse(`{"${match[4].replace(/&/g, '","').replace(/=/g, '":"')}"}`) : {});

      let loaded;
      let newRelDir = relDir;

      if (['file', 'fileFn'].includes(match[1])) {
        const filePath = match[2].startsWith('^') ? path.join(relDir, match[2].substring(1)) : path.join(dir, match[2]);
        newRelDir = path.dirname(filePath);
        loaded = filePath.endsWith('.yml') || filePath.endsWith('.yaml') ? yaml.safeLoad(fs.readFileSync(filePath, 'utf8')) // eslint-disable-next-line global-require, import/no-dynamic-require
        : require(filePath);

        if (match[1] === 'fileFn') {
          loaded = loaded(varsNew);
        }
      } else if (match[1] === 'env') {
        loaded = process.env;
      } else {
        // eslint-disable-next-line global-require, import/no-dynamic-require
        loaded = require(match[2]);
      }

      const target = match[3] ? get(loaded, match[3]) : loaded;
      result = loadRecursive(dir, newRelDir, typeof target === 'function' ? target() : target, varsNew);
      const beforeString = data.substring(0, match.index);
      const afterString = data.substring(match.index + match[0].length);

      if (beforeString.length > 0 || afterString.length > 0) {
        if (typeof result === 'string') {
          result = beforeString + result + afterString;
        } else {
          throw new TypeError(`Cannot combine string and ${typeof result}`);
        }
      }
    }
  }

  if (result instanceof Object) {
    const toMerge = get(result, '<<<', []).map(e => loadRecursive(dir, relDir, e, vars));
    delete result['<<<'];
    Object.keys(result).forEach(key => set(result, key, loadRecursive(dir, relDir, get(result, key), vars)));
    result = toMerge.reduce((prev, cur) => mergeWith(prev, cur, concatArrays), result);
  }

  return result;
};

module.exports.load = (filePath, vars = {}) => loadRecursive(path.dirname(filePath), path.dirname(filePath), yaml.safeLoad(fs.readFileSync(filePath, 'utf8')), vars);

module.exports.dump = yaml.safeDump;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwiZ2V0Iiwic2V0IiwibWVyZ2VXaXRoIiwieWFtbCIsImNvbmNhdEFycmF5cyIsIm9ialZhbHVlIiwic3JjVmFsdWUiLCJldmVyeSIsIkFycmF5IiwiaXNBcnJheSIsImNvbmNhdCIsInVuZGVmaW5lZCIsImxvYWRSZWN1cnNpdmUiLCJkaXIiLCJyZWxEaXIiLCJkYXRhIiwidmFycyIsInJlc3VsdCIsIlN0cmluZyIsInJlcGxhY2UiLCJtYXRjaCIsImsiLCJ2IiwiZXhlYyIsInZhcnNOZXciLCJKU09OIiwicGFyc2UiLCJsb2FkZWQiLCJuZXdSZWxEaXIiLCJpbmNsdWRlcyIsImZpbGVQYXRoIiwic3RhcnRzV2l0aCIsImpvaW4iLCJzdWJzdHJpbmciLCJkaXJuYW1lIiwiZW5kc1dpdGgiLCJzYWZlTG9hZCIsInJlYWRGaWxlU3luYyIsInByb2Nlc3MiLCJlbnYiLCJ0YXJnZXQiLCJiZWZvcmVTdHJpbmciLCJpbmRleCIsImFmdGVyU3RyaW5nIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiT2JqZWN0IiwidG9NZXJnZSIsIm1hcCIsImUiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInJlZHVjZSIsInByZXYiLCJjdXIiLCJtb2R1bGUiLCJleHBvcnRzIiwibG9hZCIsImR1bXAiLCJzYWZlRHVtcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBTUEsRUFBRSxHQUFHQyxPQUFPLENBQUMsSUFBRCxDQUFsQjs7QUFDQSxNQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQyxNQUFELENBQXBCOztBQUNBLE1BQU1FLEdBQUcsR0FBR0YsT0FBTyxDQUFDLFlBQUQsQ0FBbkI7O0FBQ0EsTUFBTUcsR0FBRyxHQUFHSCxPQUFPLENBQUMsWUFBRCxDQUFuQjs7QUFDQSxNQUFNSSxTQUFTLEdBQUdKLE9BQU8sQ0FBQyxrQkFBRCxDQUF6Qjs7QUFDQSxNQUFNSyxJQUFJLEdBQUdMLE9BQU8s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akMsTUFBWixFQUFvQmtDLE9BQXBCLENBQTZCQyxHQUFELElBQVNuRCxHQUFHLENBQUNnQixNQUFELEVBQVNtQyxHQUFULEVBQWN4QyxhQUFhLENBQUNDLEdBQUQsRUFBTUMsTUFBTixFQUFjZCxHQUFHLENBQUNpQixNQUFELEVBQVNtQyxHQUFULENBQWpCLEVBQWdDcEMsSUFBaEMsQ0FBM0IsQ0FBeEM7QUFDQUMsSUFBQUEsTUFBTSxHQUFHOEIsT0FBTyxDQUFDTSxNQUFSLENBQWUsQ0FBQ0MsSUFBRCxFQUFPQyxHQUFQLEtBQWVyRCxTQUFTLENBQUNvRCxJQUFELEVBQU9DLEdBQVAsRUFBWW5ELFlBQVosQ0FBdkMsRUFBa0VhLE1BQWxFLENBQVQ7QUFDRDs7QUFDRCxTQUFPQSxNQUFQO0FBQ0QsQ0E3REQ7O0FBK0RBdUMsTUFBTSxDQUFDQyxPQUFQLENBQWVDLElBQWYsR0FBc0IsQ0FBQzVCLFFBQUQsRUFBV2QsSUFBSSxHQUFHLEVBQWxCLEtBQXlCSixhQUFhLENBQzFEYixJQUFJLENBQUNtQyxPQUFMLENBQWFKLFFBQWIsQ0FEMEQsRUFFMUQvQixJQUFJLENBQUNtQyxPQUFMLENBQWFKLFFBQWIsQ0FGMEQsRUFHMUQzQixJQUFJLENBQUNpQyxRQUFMLENBQWN2QyxFQUFFLENBQUN3QyxZQUFILENBQWdCUCxRQUFoQixFQUEwQixNQUExQixDQUFkLENBSDBELEVBSTFEZCxJQUowRCxDQUE1RDs7QUFPQXdDLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlRSxJQUFmLEdBQXNCeEQsSUFBSSxDQUFDeUQsUUFBM0IiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnbG9kYXNoLmdldCcpO1xuY29uc3Qgc2V0ID0gcmVxdWlyZSgnbG9kYXNoLnNldCcpO1xuY29uc3QgbWVyZ2VXaXRoID0gcmVxdWlyZSgnbG9kYXNoLm1lcmdld2l0aCcpO1xuY29uc3QgeWFtbCA9IHJlcXVpcmUoJ2pzLXlhbWwnKTtcblxuY29uc3QgY29uY2F0QXJyYXlzID0gKG9ialZhbHVlLCBzcmNWYWx1ZSkgPT4gKFtvYmpWYWx1ZSwgc3JjVmFsdWVdXG4gIC5ldmVyeShBcnJheS5pc0FycmF5KSA/IG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSkgOiB1bmRlZmluZWQpO1xuXG5jb25zdCBsb2FkUmVjdXJzaXZlID0gKGRpciwgcmVsRGlyLCBkYXRhLCB2YXJzKSA9PiB7XG4gIGxldCByZXN1bHQgPSBkYXRhO1xuICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycgfHwgcmVzdWx0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgLy8gcmVwbGFjZSB5YW1sIHZhcmlhYmxlcyB3aXRoIGRlZmF1bHRzXG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoXG4gICAgICAvXFwke29wdDooW2EtekEtWjAtOV0rPykoPzosIFtcIiddKFthLXpBLVowLTlcXC0uXSs/KVtcIiddKT99L2csXG4gICAgICAobWF0Y2gsIGssIHYpID0+IGdldCh2YXJzLCBrLCB2IHx8IG1hdGNoKVxuICAgICk7XG4gICAgLy8gbG9hZCByZXF1aXJlc1xuICAgIGNvbnN0IG1hdGNoID0gKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgIC9cXCR7KHJlcXVpcmV8ZmlsZXxmaWxlRm58ZW52KSg/OlxcKChbfl5dP1thLXpBLVpcXGQuX1xcLUAvXSs/KVxcKSk/KD86OihbYS16QS1aXFxkLl0rPykpPyg/OiwgKFthLXpBLVpcXGQ9XFwtJi8uOltcXF0sXSs/KSk/fS9nXG4gICAgKS5leGVjKHJlc3VsdCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCB2YXJzTmV3ID0ge1xuICAgICAgICAuLi52YXJzLFxuICAgICAgICAuLi4obWF0Y2hbNF0gPyBKU09OXG4gICAgICAgICAgLnBhcnNlKGB7XCIke21hdGNoWzRdLnJlcGxhY2UoLyYvZywgJ1wiLFwiJykucmVwbGFjZSgvPS9nLCAnXCI6XCInKX1cIn1gKSA6IHt9KVxuICAgICAgfTtcblxuICAgICAgbGV0IGxvYWRlZDtcbiAgICAgIGxldCBuZXdSZWxEaXIgPSByZWxEaXI7XG4gICAgICBpZiAoWydmaWxlJywgJ2ZpbGVGbiddLmluY2x1ZGVzKG1hdGNoWzFdKSkge1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IG1hdGNoWzJdLnN0YXJ0c1dpdGgoJ14nKVxuICAgICAgICAgID8gcGF0aC5qb2luKHJlbERpciwgbWF0Y2hbMl0uc3Vic3RyaW5nKDEpKVxuICAgICAgICAgIDogcGF0aC5qb2luKGRpciwgbWF0Y2hbMl0pO1xuICAgICAgICBuZXdSZWxEaXIgPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBsb2FkZWQgPSAoZmlsZVBhdGguZW5kc1dpdGgoJy55bWwnKSB8fCBmaWxlUGF0aC5lbmRzV2l0aCgnLnlhbWwnKSlcbiAgICAgICAgICA/IHlhbWwuc2FmZUxvYWQoZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpKVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZSwgaW1wb3J0L25vLWR5bmFtaWMtcmVxdWlyZVxuICAgICAgICAgIDogcmVxdWlyZShmaWxlUGF0aCk7XG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJ2ZpbGVGbicpIHtcbiAgICAgICAgICBsb2FkZWQgPSBsb2FkZWQodmFyc05ldyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMV0gPT09ICdlbnYnKSB7XG4gICAgICAgIGxvYWRlZCA9IHByb2Nlc3MuZW52O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlLCBpbXBvcnQvbm8tZHluYW1pYy1yZXF1aXJlXG4gICAgICAgIGxvYWRlZCA9IHJlcXVpcmUobWF0Y2hbMl0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0ID0gbWF0Y2hbM10gPyBnZXQobG9hZGVkLCBtYXRjaFszXSkgOiBsb2FkZWQ7XG4gICAgICByZXN1bHQgPSBsb2FkUmVjdXJzaXZlKGRpciwgbmV3UmVsRGlyLCB0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gdGFyZ2V0KCkgOiB0YXJnZXQsIHZhcnNOZXcpO1xuXG4gICAgICBjb25zdCBiZWZvcmVTdHJpbmcgPSBkYXRhLnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCk7XG4gICAgICBjb25zdCBhZnRlclN0cmluZyA9IGRhdGEuc3Vic3RyaW5nKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChiZWZvcmVTdHJpbmcubGVuZ3RoID4gMCB8fCBhZnRlclN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJlc3VsdCA9IGJlZm9yZVN0cmluZyArIHJlc3VsdCArIGFmdGVyU3RyaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBjb21iaW5lIHN0cmluZyBhbmQgJHt0eXBlb2YgcmVzdWx0fWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBjb25zdCB0b01lcmdlID0gZ2V0KHJlc3VsdCwgJzw8PCcsIFtdKS5tYXAoKGUpID0+IGxvYWRSZWN1cnNpdmUoZGlyLCByZWxEaXIsIGUsIHZhcnMpKTtcbiAgICBkZWxldGUgcmVzdWx0Wyc8PDwnXTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goKGtleSkgPT4gc2V0KHJlc3VsdCwga2V5LCBsb2FkUmVjdXJzaXZlKGRpciwgcmVsRGlyLCBnZXQocmVzdWx0LCBrZXkpLCB2YXJzKSkpO1xuICAgIHJlc3VsdCA9IHRvTWVyZ2UucmVkdWNlKChwcmV2LCBjdXIpID0+IG1lcmdlV2l0aChwcmV2LCBjdXIsIGNvbmNhdEFycmF5cyksIHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmxvYWQgPSAoZmlsZVBhdGgsIHZhcnMgPSB7fSkgPT4gbG9hZFJlY3Vyc2l2ZShcbiAgcGF0aC5kaXJuYW1lKGZpbGVQYXRoKSxcbiAgcGF0aC5kaXJuYW1lKGZpbGVQYXRoKSxcbiAgeWFtbC5zYWZlTG9hZChmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4JykpLFxuICB2YXJzXG4pO1xuXG5tb2R1bGUuZXhwb3J0cy5kdW1wID0geWFtbC5zYWZlRHVtcDtcbiJdfQ==