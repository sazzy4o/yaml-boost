function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const fs = require('fs');

const path = require('path');

const get = require('lodash.get');

const set = require('lodash.set');

const mergeWith = require('lodash.mergewith');

const yaml = require('js-yaml');

const concatArrays = (objValue, srcValue) => [objValue, srcValue].every(Array.isArray) ? objValue.concat(srcValue) : undefined;

const loadRecursive = (dir, relDir, data, vars) => {
  let result = data;

  if (typeof result === 'string' || result instanceof String) {
    // replace yaml variables with defaults
    result = result.replace(/\${opt:([a-zA-Z0-9]+?)(?:, ["']([a-zA-Z0-9\-.]+?)["'])?}/g, (match, k, v) => get(vars, k, v || match)); // load requires

    const match = // eslint-disable-next-line max-len
    /^\${(require|file|fileFn|env)(?:\(([~^]?[a-zA-Z\d._\-@/]+?)\))?(?::([a-zA-Z\d.]+?))?(?:, ([a-zA-Z\d=\-&/.:[\],]+?))?}/g.exec(result);

    if (match) {
      const varsNew = _objectSpread(_objectSpread({}, vars), match[4] ? JSON.parse(`{"${match[4].replace(/&/g, '","').replace(/=/g, '":"')}"}`) : {});

      let loaded;
      let newRelDir = relDir;

      if (['file', 'fileFn'].includes(match[1])) {
        const filePath = match[2].startsWith('^') ? path.join(relDir, match[2].substring(1)) : path.join(dir, match[2]);
        newRelDir = path.dirname(filePath);
        loaded = filePath.endsWith('.yml') || filePath.endsWith('.yaml') ? yaml.safeLoad(fs.readFileSync(filePath, 'utf8')) // eslint-disable-next-line global-require, import/no-dynamic-require
        : require(filePath);

        if (match[1] === 'fileFn') {
          loaded = loaded(varsNew);
        }
      } else if (match[1] === 'env') {
        loaded = process.env;
      } else {
        // eslint-disable-next-line global-require, import/no-dynamic-require
        loaded = require(match[2]);
      }

      const target = match[3] ? get(loaded, match[3]) : loaded;
      result = loadRecursive(dir, newRelDir, typeof target === 'function' ? target() : target, varsNew);
      const beforeString = data.substring(0, match.index);
      const afterString = data.substring(match.index + match[1].length);

      if (beforeString.length > 0 || afterString.length > 0) {
        if (typeof result === 'string') {
          result = beforeString + result + afterString;
        } else {
          throw new TypeError(`Cannot combine string and ${typeof result}`);
        }
      }
    }
  }

  if (result instanceof Object) {
    const toMerge = get(result, '<<<', []).map(e => loadRecursive(dir, relDir, e, vars));
    delete result['<<<'];
    Object.keys(result).forEach(key => set(result, key, loadRecursive(dir, relDir, get(result, key), vars)));
    result = toMerge.reduce((prev, cur) => mergeWith(prev, cur, concatArrays), result);
  }

  return result;
};

module.exports.load = (filePath, vars = {}) => loadRecursive(path.dirname(filePath), path.dirname(filePath), yaml.safeLoad(fs.readFileSync(filePath, 'utf8')), vars);

module.exports.dump = yaml.safeDump;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwiZ2V0Iiwic2V0IiwibWVyZ2VXaXRoIiwieWFtbCIsImNvbmNhdEFycmF5cyIsIm9ialZhbHVlIiwic3JjVmFsdWUiLCJldmVyeSIsIkFycmF5IiwiaXNBcnJheSIsImNvbmNhdCIsInVuZGVmaW5lZCIsImxvYWRSZWN1cnNpdmUiLCJkaXIiLCJyZWxEaXIiLCJkYXRhIiwidmFycyIsInJlc3VsdCIsIlN0cmluZyIsInJlcGxhY2UiLCJtYXRjaCIsImsiLCJ2IiwiZXhlYyIsInZhcnNOZXciLCJKU09OIiwicGFyc2UiLCJsb2FkZWQiLCJuZXdSZWxEaXIiLCJpbmNsdWRlcyIsImZpbGVQYXRoIiwic3RhcnRzV2l0aCIsImpvaW4iLCJzdWJzdHJpbmciLCJkaXJuYW1lIiwiZW5kc1dpdGgiLCJzYWZlTG9hZCIsInJlYWRGaWxlU3luYyIsInByb2Nlc3MiLCJlbnYiLCJ0YXJnZXQiLCJiZWZvcmVTdHJpbmciLCJpbmRleCIsImFmdGVyU3RyaW5nIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiT2JqZWN0IiwidG9NZXJnZSIsIm1hcCIsImUiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInJlZHVjZSIsInByZXYiLCJjdXIiLCJtb2R1bGUiLCJleHBvcnRzIiwibG9hZCIsImR1bXAiLCJzYWZlRHVtcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBTUEsRUFBRSxHQUFHQyxPQUFPLENBQUMsSUFBRCxDQUFsQjs7QUFDQSxNQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQyxNQUFELENBQXBCOztBQUNBLE1BQU1FLEdBQUcsR0FBR0YsT0FBTyxDQUFDLFlBQUQsQ0FBbkI7O0FBQ0EsTUFBTUcsR0FBRyxHQUFHSCxPQUFPLENBQUMsWUFBRCxDQUFuQjs7QUFDQSxNQUFNSSxTQUFTLEdBQUdKLE9BQU8sQ0FBQyxrQkFBRCxDQUF6Qjs7QUFDQSxNQUFNSyxJQUFJLEdBQUdMLE9BQU8s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akMsTUFBWixFQUFvQmtDLE9BQXBCLENBQTZCQyxHQUFELElBQVNuRCxHQUFHLENBQUNnQixNQUFELEVBQVNtQyxHQUFULEVBQWN4QyxhQUFhLENBQUNDLEdBQUQsRUFBTUMsTUFBTixFQUFjZCxHQUFHLENBQUNpQixNQUFELEVBQVNtQyxHQUFULENBQWpCLEVBQWdDcEMsSUFBaEMsQ0FBM0IsQ0FBeEM7QUFDQUMsSUFBQUEsTUFBTSxHQUFHOEIsT0FBTyxDQUFDTSxNQUFSLENBQWUsQ0FBQ0MsSUFBRCxFQUFPQyxHQUFQLEtBQWVyRCxTQUFTLENBQUNvRCxJQUFELEVBQU9DLEdBQVAsRUFBWW5ELFlBQVosQ0FBdkMsRUFBa0VhLE1BQWxFLENBQVQ7QUFDRDs7QUFDRCxTQUFPQSxNQUFQO0FBQ0QsQ0E3REQ7O0FBK0RBdUMsTUFBTSxDQUFDQyxPQUFQLENBQWVDLElBQWYsR0FBc0IsQ0FBQzVCLFFBQUQsRUFBV2QsSUFBSSxHQUFHLEVBQWxCLEtBQXlCSixhQUFhLENBQzFEYixJQUFJLENBQUNtQyxPQUFMLENBQWFKLFFBQWIsQ0FEMEQsRUFFMUQvQixJQUFJLENBQUNtQyxPQUFMLENBQWFKLFFBQWIsQ0FGMEQsRUFHMUQzQixJQUFJLENBQUNpQyxRQUFMLENBQWN2QyxFQUFFLENBQUN3QyxZQUFILENBQWdCUCxRQUFoQixFQUEwQixNQUExQixDQUFkLENBSDBELEVBSTFEZCxJQUowRCxDQUE1RDs7QUFPQXdDLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlRSxJQUFmLEdBQXNCeEQsSUFBSSxDQUFDeUQsUUFBM0IiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnbG9kYXNoLmdldCcpO1xuY29uc3Qgc2V0ID0gcmVxdWlyZSgnbG9kYXNoLnNldCcpO1xuY29uc3QgbWVyZ2VXaXRoID0gcmVxdWlyZSgnbG9kYXNoLm1lcmdld2l0aCcpO1xuY29uc3QgeWFtbCA9IHJlcXVpcmUoJ2pzLXlhbWwnKTtcblxuY29uc3QgY29uY2F0QXJyYXlzID0gKG9ialZhbHVlLCBzcmNWYWx1ZSkgPT4gKFtvYmpWYWx1ZSwgc3JjVmFsdWVdXG4gIC5ldmVyeShBcnJheS5pc0FycmF5KSA/IG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSkgOiB1bmRlZmluZWQpO1xuXG5jb25zdCBsb2FkUmVjdXJzaXZlID0gKGRpciwgcmVsRGlyLCBkYXRhLCB2YXJzKSA9PiB7XG4gIGxldCByZXN1bHQgPSBkYXRhO1xuICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycgfHwgcmVzdWx0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgLy8gcmVwbGFjZSB5YW1sIHZhcmlhYmxlcyB3aXRoIGRlZmF1bHRzXG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoXG4gICAgICAvXFwke29wdDooW2EtekEtWjAtOV0rPykoPzosIFtcIiddKFthLXpBLVowLTlcXC0uXSs/KVtcIiddKT99L2csXG4gICAgICAobWF0Y2gsIGssIHYpID0+IGdldCh2YXJzLCBrLCB2IHx8IG1hdGNoKVxuICAgICk7XG4gICAgLy8gbG9hZCByZXF1aXJlc1xuICAgIGNvbnN0IG1hdGNoID0gKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgIC9eXFwkeyhyZXF1aXJlfGZpbGV8ZmlsZUZufGVudikoPzpcXCgoW35eXT9bYS16QS1aXFxkLl9cXC1AL10rPylcXCkpPyg/OjooW2EtekEtWlxcZC5dKz8pKT8oPzosIChbYS16QS1aXFxkPVxcLSYvLjpbXFxdLF0rPykpP30vZ1xuICAgICkuZXhlYyhyZXN1bHQpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgdmFyc05ldyA9IHtcbiAgICAgICAgLi4udmFycyxcbiAgICAgICAgLi4uKG1hdGNoWzRdID8gSlNPTlxuICAgICAgICAgIC5wYXJzZShge1wiJHttYXRjaFs0XS5yZXBsYWNlKC8mL2csICdcIixcIicpLnJlcGxhY2UoLz0vZywgJ1wiOlwiJyl9XCJ9YCkgOiB7fSlcbiAgICAgIH07XG5cbiAgICAgIGxldCBsb2FkZWQ7XG4gICAgICBsZXQgbmV3UmVsRGlyID0gcmVsRGlyO1xuICAgICAgaWYgKFsnZmlsZScsICdmaWxlRm4nXS5pbmNsdWRlcyhtYXRjaFsxXSkpIHtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBtYXRjaFsyXS5zdGFydHNXaXRoKCdeJylcbiAgICAgICAgICA/IHBhdGguam9pbihyZWxEaXIsIG1hdGNoWzJdLnN1YnN0cmluZygxKSlcbiAgICAgICAgICA6IHBhdGguam9pbihkaXIsIG1hdGNoWzJdKTtcbiAgICAgICAgbmV3UmVsRGlyID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgICAgICAgbG9hZGVkID0gKGZpbGVQYXRoLmVuZHNXaXRoKCcueW1sJykgfHwgZmlsZVBhdGguZW5kc1dpdGgoJy55YW1sJykpXG4gICAgICAgICAgPyB5YW1sLnNhZmVMb2FkKGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKSlcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmUsIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmVcbiAgICAgICAgICA6IHJlcXVpcmUoZmlsZVBhdGgpO1xuICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICdmaWxlRm4nKSB7XG4gICAgICAgICAgbG9hZGVkID0gbG9hZGVkKHZhcnNOZXcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoWzFdID09PSAnZW52Jykge1xuICAgICAgICBsb2FkZWQgPSBwcm9jZXNzLmVudjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZSwgaW1wb3J0L25vLWR5bmFtaWMtcmVxdWlyZVxuICAgICAgICBsb2FkZWQgPSByZXF1aXJlKG1hdGNoWzJdKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldCA9IG1hdGNoWzNdID8gZ2V0KGxvYWRlZCwgbWF0Y2hbM10pIDogbG9hZGVkO1xuICAgICAgcmVzdWx0ID0gbG9hZFJlY3Vyc2l2ZShkaXIsIG5ld1JlbERpciwgdHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJyA/IHRhcmdldCgpIDogdGFyZ2V0LCB2YXJzTmV3KTtcblxuICAgICAgY29uc3QgYmVmb3JlU3RyaW5nID0gZGF0YS5zdWJzdHJpbmcoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgY29uc3QgYWZ0ZXJTdHJpbmcgPSBkYXRhLnN1YnN0cmluZyhtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICBpZiAoYmVmb3JlU3RyaW5nLmxlbmd0aCA+IDAgfHwgYWZ0ZXJTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXN1bHQgPSBiZWZvcmVTdHJpbmcgKyByZXN1bHQgKyBhZnRlclN0cmluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgY29tYmluZSBzdHJpbmcgYW5kICR7dHlwZW9mIHJlc3VsdH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgY29uc3QgdG9NZXJnZSA9IGdldChyZXN1bHQsICc8PDwnLCBbXSkubWFwKChlKSA9PiBsb2FkUmVjdXJzaXZlKGRpciwgcmVsRGlyLCBlLCB2YXJzKSk7XG4gICAgZGVsZXRlIHJlc3VsdFsnPDw8J107XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKChrZXkpID0+IHNldChyZXN1bHQsIGtleSwgbG9hZFJlY3Vyc2l2ZShkaXIsIHJlbERpciwgZ2V0KHJlc3VsdCwga2V5KSwgdmFycykpKTtcbiAgICByZXN1bHQgPSB0b01lcmdlLnJlZHVjZSgocHJldiwgY3VyKSA9PiBtZXJnZVdpdGgocHJldiwgY3VyLCBjb25jYXRBcnJheXMpLCByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5sb2FkID0gKGZpbGVQYXRoLCB2YXJzID0ge30pID0+IGxvYWRSZWN1cnNpdmUoXG4gIHBhdGguZGlybmFtZShmaWxlUGF0aCksXG4gIHBhdGguZGlybmFtZShmaWxlUGF0aCksXG4gIHlhbWwuc2FmZUxvYWQoZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpKSxcbiAgdmFyc1xuKTtcblxubW9kdWxlLmV4cG9ydHMuZHVtcCA9IHlhbWwuc2FmZUR1bXA7XG4iXX0=