function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const fs = require('fs');

const path = require('path');

const get = require('lodash.get');

const set = require('lodash.set');

const mergeWith = require('lodash.mergewith');

const yaml = require('js-yaml');

const concatArrays = (objValue, srcValue) => [objValue, srcValue].every(Array.isArray) ? objValue.concat(srcValue) : undefined;

const loadRecursive = (dir, relDir, data, vars) => {
  let result = data;

  if (typeof result === 'string' || result instanceof String) {
    // replace yaml variables with defaults
    result = result.replace(/\${opt:([a-zA-Z0-9]+?)(?:, ["']([a-zA-Z0-9\-.]+?)["'])?}/g, (match, k, v) => get(vars, k, v || match)); // load requires

    const match = // eslint-disable-next-line max-len
    /^\${(require|file|fileFn|env)(?:\(([~^]?[a-zA-Z\d._\-@/]+?)\))?(?::([a-zA-Z\d.]+?))?(?:, ([a-zA-Z\d=\-&/.:[\],]+?))?}/g.exec(result);

    if (match) {
      const varsNew = _objectSpread(_objectSpread({}, vars), match[4] ? JSON.parse(`{"${match[4].replace(/&/g, '","').replace(/=/g, '":"')}"}`) : {});

      let loaded;
      let newRelDir = relDir;

      if (['file', 'fileFn'].includes(match[1])) {
        const filePath = match[2].startsWith('^') ? path.join(relDir, match[2].substring(1)) : path.join(dir, match[2]);
        newRelDir = path.dirname(filePath);
        loaded = filePath.endsWith('.yml') || filePath.endsWith('.yaml') ? yaml.safeLoad(fs.readFileSync(filePath, 'utf8')) // eslint-disable-next-line global-require, import/no-dynamic-require
        : require(filePath);

        if (match[1] === 'fileFn') {
          loaded = loaded(varsNew);
        }
      } else if (match[1] === 'env') {
        loaded = process.env;
      } else {
        // eslint-disable-next-line global-require, import/no-dynamic-require
        loaded = require(match[2]);
      }

      const target = match[3] ? get(loaded, match[3]) : loaded;
      result = loadRecursive(dir, newRelDir, typeof target === 'function' ? target() : target, varsNew);
      const beforeString = data.substring(0, match.index);
      const afterString = data.substring(match.index + match[1].length);

      if (beforeString.length > 0 || afterString.length > 0) {
        if (typeof result === 'string') {
          result = beforeString + result + afterString;
        } else {
          console.log('//! TODO Throw exception');
        }
      }
    }
  }

  if (result instanceof Object) {
    const toMerge = get(result, '<<<', []).map(e => loadRecursive(dir, relDir, e, vars));
    delete result['<<<'];
    Object.keys(result).forEach(key => set(result, key, loadRecursive(dir, relDir, get(result, key), vars)));
    result = toMerge.reduce((prev, cur) => mergeWith(prev, cur, concatArrays), result);
  }

  return result;
};

module.exports.load = (filePath, vars = {}) => loadRecursive(path.dirname(filePath), path.dirname(filePath), yaml.safeLoad(fs.readFileSync(filePath, 'utf8')), vars);

module.exports.dump = yaml.safeDump;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwiZ2V0Iiwic2V0IiwibWVyZ2VXaXRoIiwieWFtbCIsImNvbmNhdEFycmF5cyIsIm9ialZhbHVlIiwic3JjVmFsdWUiLCJldmVyeSIsIkFycmF5IiwiaXNBcnJheSIsImNvbmNhdCIsInVuZGVmaW5lZCIsImxvYWRSZWN1cnNpdmUiLCJkaXIiLCJyZWxEaXIiLCJkYXRhIiwidmFycyIsInJlc3VsdCIsIlN0cmluZyIsInJlcGxhY2UiLCJtYXRjaCIsImsiLCJ2IiwiZXhlYyIsInZhcnNOZXciLCJKU09OIiwicGFyc2UiLCJsb2FkZWQiLCJuZXdSZWxEaXIiLCJpbmNsdWRlcyIsImZpbGVQYXRoIiwic3RhcnRzV2l0aCIsImpvaW4iLCJzdWJzdHJpbmciLCJkaXJuYW1lIiwiZW5kc1dpdGgiLCJzYWZlTG9hZCIsInJlYWRGaWxlU3luYyIsInByb2Nlc3MiLCJlbnYiLCJ0YXJnZXQiLCJiZWZvcmVTdHJpbmciLCJpbmRleCIsImFmdGVyU3RyaW5nIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsIk9iamVjdCIsInRvTWVyZ2UiLCJtYXAiLCJlIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvYWQiLCJkdW1wIiwic2FmZUR1bXAiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQU1BLEVBQUUsR0FBR0MsT0FBTyxDQUFDLElBQUQsQ0FBbEI7O0FBQ0EsTUFBTUMsSUFBSSxHQUFHRCxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxNQUFNRSxHQUFHLEdBQUdGLE9BQU8sQ0FBQyxZQUFELENBQW5COztBQUNBLE1BQU1HLEdBQUcsR0FBR0gsT0FBTyxDQUFDLFlBQUQsQ0FBbkI7O0FBQ0EsTUFBTUksU0FBUyxHQUFHSixPQUFPLENBQUMsa0JBQUQsQ0FBekI7O0FBQ0EsTUFBTUssSUFBSSxHQUFHTCxP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bUMsT0FBcEIsQ0FBNkJDLEdBQUQsSUFBU3BELEdBQUcsQ0FBQ2dCLE1BQUQsRUFBU29DLEdBQVQsRUFBY3pDLGFBQWEsQ0FBQ0MsR0FBRCxFQUFNQyxNQUFOLEVBQWNkLEdBQUcsQ0FBQ2lCLE1BQUQsRUFBU29DLEdBQVQsQ0FBakIsRUFBZ0NyQyxJQUFoQyxDQUEzQixDQUF4QztBQUNBQyxJQUFBQSxNQUFNLEdBQUcrQixPQUFPLENBQUNNLE1BQVIsQ0FBZSxDQUFDQyxJQUFELEVBQU9DLEdBQVAsS0FBZXRELFNBQVMsQ0FBQ3FELElBQUQsRUFBT0MsR0FBUCxFQUFZcEQsWUFBWixDQUF2QyxFQUFrRWEsTUFBbEUsQ0FBVDtBQUNEOztBQUNELFNBQU9BLE1BQVA7QUFDRCxDQTdERDs7QUErREF3QyxNQUFNLENBQUNDLE9BQVAsQ0FBZUMsSUFBZixHQUFzQixDQUFDN0IsUUFBRCxFQUFXZCxJQUFJLEdBQUcsRUFBbEIsS0FBeUJKLGFBQWEsQ0FDMURiLElBQUksQ0FBQ21DLE9BQUwsQ0FBYUosUUFBYixDQUQwRCxFQUUxRC9CLElBQUksQ0FBQ21DLE9BQUwsQ0FBYUosUUFBYixDQUYwRCxFQUcxRDNCLElBQUksQ0FBQ2lDLFFBQUwsQ0FBY3ZDLEVBQUUsQ0FBQ3dDLFlBQUgsQ0FBZ0JQLFFBQWhCLEVBQTBCLE1BQTFCLENBQWQsQ0FIMEQsRUFJMURkLElBSjBELENBQTVEOztBQU9BeUMsTUFBTSxDQUFDQyxPQUFQLENBQWVFLElBQWYsR0FBc0J6RCxJQUFJLENBQUMwRCxRQUEzQiIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCdsb2Rhc2guZ2V0Jyk7XG5jb25zdCBzZXQgPSByZXF1aXJlKCdsb2Rhc2guc2V0Jyk7XG5jb25zdCBtZXJnZVdpdGggPSByZXF1aXJlKCdsb2Rhc2gubWVyZ2V3aXRoJyk7XG5jb25zdCB5YW1sID0gcmVxdWlyZSgnanMteWFtbCcpO1xuXG5jb25zdCBjb25jYXRBcnJheXMgPSAob2JqVmFsdWUsIHNyY1ZhbHVlKSA9PiAoW29ialZhbHVlLCBzcmNWYWx1ZV1cbiAgLmV2ZXJ5KEFycmF5LmlzQXJyYXkpID8gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKSA6IHVuZGVmaW5lZCk7XG5cbmNvbnN0IGxvYWRSZWN1cnNpdmUgPSAoZGlyLCByZWxEaXIsIGRhdGEsIHZhcnMpID0+IHtcbiAgbGV0IHJlc3VsdCA9IGRhdGE7XG4gIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJyB8fCByZXN1bHQgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAvLyByZXBsYWNlIHlhbWwgdmFyaWFibGVzIHdpdGggZGVmYXVsdHNcbiAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShcbiAgICAgIC9cXCR7b3B0OihbYS16QS1aMC05XSs/KSg/OiwgW1wiJ10oW2EtekEtWjAtOVxcLS5dKz8pW1wiJ10pP30vZyxcbiAgICAgIChtYXRjaCwgaywgdikgPT4gZ2V0KHZhcnMsIGssIHYgfHwgbWF0Y2gpXG4gICAgKTtcbiAgICAvLyBsb2FkIHJlcXVpcmVzXG4gICAgY29uc3QgbWF0Y2ggPSAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgL15cXCR7KHJlcXVpcmV8ZmlsZXxmaWxlRm58ZW52KSg/OlxcKChbfl5dP1thLXpBLVpcXGQuX1xcLUAvXSs/KVxcKSk/KD86OihbYS16QS1aXFxkLl0rPykpPyg/OiwgKFthLXpBLVpcXGQ9XFwtJi8uOltcXF0sXSs/KSk/fS9nXG4gICAgKS5leGVjKHJlc3VsdCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCB2YXJzTmV3ID0ge1xuICAgICAgICAuLi52YXJzLFxuICAgICAgICAuLi4obWF0Y2hbNF0gPyBKU09OXG4gICAgICAgICAgLnBhcnNlKGB7XCIke21hdGNoWzRdLnJlcGxhY2UoLyYvZywgJ1wiLFwiJykucmVwbGFjZSgvPS9nLCAnXCI6XCInKX1cIn1gKSA6IHt9KVxuICAgICAgfTtcblxuICAgICAgbGV0IGxvYWRlZDtcbiAgICAgIGxldCBuZXdSZWxEaXIgPSByZWxEaXI7XG4gICAgICBpZiAoWydmaWxlJywgJ2ZpbGVGbiddLmluY2x1ZGVzKG1hdGNoWzFdKSkge1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IG1hdGNoWzJdLnN0YXJ0c1dpdGgoJ14nKVxuICAgICAgICAgID8gcGF0aC5qb2luKHJlbERpciwgbWF0Y2hbMl0uc3Vic3RyaW5nKDEpKVxuICAgICAgICAgIDogcGF0aC5qb2luKGRpciwgbWF0Y2hbMl0pO1xuICAgICAgICBuZXdSZWxEaXIgPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBsb2FkZWQgPSAoZmlsZVBhdGguZW5kc1dpdGgoJy55bWwnKSB8fCBmaWxlUGF0aC5lbmRzV2l0aCgnLnlhbWwnKSlcbiAgICAgICAgICA/IHlhbWwuc2FmZUxvYWQoZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpKVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZSwgaW1wb3J0L25vLWR5bmFtaWMtcmVxdWlyZVxuICAgICAgICAgIDogcmVxdWlyZShmaWxlUGF0aCk7XG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJ2ZpbGVGbicpIHtcbiAgICAgICAgICBsb2FkZWQgPSBsb2FkZWQodmFyc05ldyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMV0gPT09ICdlbnYnKSB7XG4gICAgICAgIGxvYWRlZCA9IHByb2Nlc3MuZW52O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlLCBpbXBvcnQvbm8tZHluYW1pYy1yZXF1aXJlXG4gICAgICAgIGxvYWRlZCA9IHJlcXVpcmUobWF0Y2hbMl0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0ID0gbWF0Y2hbM10gPyBnZXQobG9hZGVkLCBtYXRjaFszXSkgOiBsb2FkZWQ7XG4gICAgICByZXN1bHQgPSBsb2FkUmVjdXJzaXZlKGRpciwgbmV3UmVsRGlyLCB0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gdGFyZ2V0KCkgOiB0YXJnZXQsIHZhcnNOZXcpO1xuXG4gICAgICBjb25zdCBiZWZvcmVTdHJpbmcgPSBkYXRhLnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCk7XG4gICAgICBjb25zdCBhZnRlclN0cmluZyA9IGRhdGEuc3Vic3RyaW5nKG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoKTtcbiAgICAgIGlmIChiZWZvcmVTdHJpbmcubGVuZ3RoID4gMCB8fCBhZnRlclN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJlc3VsdCA9IGJlZm9yZVN0cmluZyArIHJlc3VsdCArIGFmdGVyU3RyaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCcvLyEgVE9ETyBUaHJvdyBleGNlcHRpb24nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgY29uc3QgdG9NZXJnZSA9IGdldChyZXN1bHQsICc8PDwnLCBbXSkubWFwKChlKSA9PiBsb2FkUmVjdXJzaXZlKGRpciwgcmVsRGlyLCBlLCB2YXJzKSk7XG4gICAgZGVsZXRlIHJlc3VsdFsnPDw8J107XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKChrZXkpID0+IHNldChyZXN1bHQsIGtleSwgbG9hZFJlY3Vyc2l2ZShkaXIsIHJlbERpciwgZ2V0KHJlc3VsdCwga2V5KSwgdmFycykpKTtcbiAgICByZXN1bHQgPSB0b01lcmdlLnJlZHVjZSgocHJldiwgY3VyKSA9PiBtZXJnZVdpdGgocHJldiwgY3VyLCBjb25jYXRBcnJheXMpLCByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5sb2FkID0gKGZpbGVQYXRoLCB2YXJzID0ge30pID0+IGxvYWRSZWN1cnNpdmUoXG4gIHBhdGguZGlybmFtZShmaWxlUGF0aCksXG4gIHBhdGguZGlybmFtZShmaWxlUGF0aCksXG4gIHlhbWwuc2FmZUxvYWQoZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpKSxcbiAgdmFyc1xuKTtcblxubW9kdWxlLmV4cG9ydHMuZHVtcCA9IHlhbWwuc2FmZUR1bXA7XG4iXX0=